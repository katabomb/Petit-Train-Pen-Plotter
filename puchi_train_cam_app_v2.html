<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>ãƒ—ãƒé›»è»Šãƒšãƒ³ãƒ—ãƒ­ãƒƒã‚¿2ï¼šå®Œæˆå›³PNGï¼†3ã‚«ãƒ PNGï¼ˆÎ±/Î²/Zï¼‰</title>
  <style>
    :root{
      --bg:#0b0c10; --panel:#141722; --ink:#e9ecf1; --muted:#aab2c0; --line:#2a3142;
      --btn:#0f1220; --btn2:#0b2733; --acc:#7dd3fc;
    }
    *{ box-sizing:border-box; }
    body{ margin:0; font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",sans-serif; background:var(--bg); color:var(--ink); }
    header{ padding:12px 14px; border-bottom:1px solid var(--line); }
    header h1{ margin:0; font-size:15px; }
    header p{ margin:6px 0 0; font-size:12px; color:var(--muted); line-height:1.4; }

    .wrap{ display:grid; grid-template-columns: minmax(280px,380px) 1fr; gap:10px; padding:10px; }
    @media (max-width: 900px){ .wrap{ grid-template-columns:1fr; } }

    .card{ background:var(--panel); border:1px solid var(--line); border-radius:14px; padding:10px; }
    h2{ margin:0 0 8px; font-size:13px; color:#dbe4ff; }
    label{ display:block; font-size:11px; color:var(--muted); margin:0 0 4px; }
    input, select, textarea{
      width:100%; padding:7px 9px; border-radius:10px; border:1px solid var(--line);
      background:#0f1220; color:var(--ink); font-size:13px;
    }
    textarea{ min-height:120px; resize:vertical; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .grid2{ display:grid; grid-template-columns:1fr 1fr; gap:6px; }
    .row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    button{
      padding:8px 10px; border-radius:12px; border:1px solid var(--line);
      background:var(--btn); color:var(--ink); font-weight:650; cursor:pointer;
    }
    button.primary{ background:var(--btn2); border-color:#2b8ab1; }
    .small{ font-size:11px; color:var(--muted); line-height:1.45; }
    .kpi{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; color:#d3f9d8; line-height:1.45; }

    .canvasWrap{ width:100%; aspect-ratio: 3 / 4; }
    canvas{ width:100%; height:100%; display:block; border-radius:12px; border:1px solid var(--line); background:#070812; }
    .three{ display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px; }
    @media (max-width: 900px){ .three{ grid-template-columns:1fr; } }
  </style>
</head>
<body>
<header>
  <h1>ãƒ—ãƒé›»è»Šãƒšãƒ³ãƒ—ãƒ­ãƒƒã‚¿2ï¼šå®Œæˆå›³PNG & 3ã‚«ãƒ PNGï¼ˆÎ±/Î²/Zï¼‰</h1>
  <p>
    â‘ ç·šæ–‡ï¼ˆè¤‡æ•°ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ï¼‰â†’å®Œæˆå›³PNGã€€â‘¡åŒã˜Î¸ã§ Î±/Î²/Z ã®3ã‚«ãƒ ã‚’ç”Ÿæˆâ†’åˆ‡ã‚ŠæŠœãç”¨PNGã€‚<br/>
    iPhoneã¯è‡ªå‹•å†ç”Ÿã§ããªã„ã®ã§ã€å¿…ãšã€Œâ–¶å†ç”Ÿã€ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ãã ã•ã„ğŸ˜Š
  </p>
</header>

<div class="wrap">
  <section class="card">
    <h2>1) å½¢ï¼ˆç·šæ–‡ï¼‰</h2>
    <div class="small">ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆï¼š1è¡Œ=1ç‚¹ã€Œx,yã€ã€‚ç©ºè¡Œã§ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯åŒºåˆ‡ã‚Šã€‚å˜ä½ã¯mmã€‚</div>
    <textarea id="strokes"></textarea>
    <div class="row" style="margin-top:8px;">
      <button id="loadSquare">ã‚µãƒ³ãƒ—ãƒ«ï¼š75mmè§’ï¼ˆ2ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ï¼‰</button>
      <button id="loadStar">ã‚µãƒ³ãƒ—ãƒ«ï¼šæ˜Ÿï¼ˆ1ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ï¼‰</button>
      <button id="loadHilbert">ã‚µãƒ³ãƒ—ãƒ«ï¼šãƒ’ãƒ«ãƒ™ãƒ«ãƒˆé¢¨ï¼ˆå¤šæŠ˜ã‚Œï¼‰</button>
    </div>

    <h2 style="margin-top:12px;">2) æ©Ÿæ§‹ï¼ˆXYï¼‰</h2>
    <div class="grid2">
      <div><label>ã‚¢ãƒ¼ãƒ é•· l (mm)</label><input id="l" type="number" value="90" step="1"></div>
      <div><label>è»Œè·¡ã‚ªãƒ•ã‚»ãƒƒãƒˆ X0 (mm)</label><input id="x0" type="number" value="0" step="1"></div>
      <div><label>è»Œè·¡ã‚ªãƒ•ã‚»ãƒƒãƒˆ Y0 (mm)</label><input id="y0" type="number" value="130" step="1"></div>
      <div><label>1å‘¨ã‚µãƒ³ãƒ—ãƒ«ç‚¹ N</label><input id="N" type="number" value="720" step="60"></div>
    </div>

    <h2 style="margin-top:12px;">3) Zï¼ˆç´™å° 0/10mmï¼‰ã¨ä½™ç™½</h2>
    <div class="grid2">
      <div><label>Zã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ (mm)</label><input id="zStroke" type="number" value="10" step="1"></div>
      <div><label>å¾…ã¡è§’ï¼ˆãƒšãƒ³OFFï¼‰(deg)</label><input id="waitDeg" type="number" value="15" step="1"></div>
      <div><label>ä¸Šã’è§’ï¼ˆãƒšãƒ³ONã¸ï¼‰(deg)</label><input id="zUpDeg" type="number" value="6" step="1"></div>
      <div><label>ä¸‹ã’è§’ï¼ˆãƒšãƒ³OFFã¸ï¼‰(deg)</label><input id="zDownDeg" type="number" value="3" step="1"></div>
    </div>
    <div class="small">â€» Zå‹•ä½œä¸­ã¯XYã‚’åœæ­¢ï¼ˆåŒä¸€ç‚¹ã«æ»åœ¨ï¼‰ã«ã—ã¦ã„ã¾ã™ã€‚å¾…ã¡è§’ã¯ä½œæ¥­ç”¨ã®ä½™ç™½ã§ã™ã€‚</div>

    <h2 style="margin-top:12px;">4) ã‚«ãƒ åŠå¾„ï¼ˆå°åˆ·ç”¨ï¼‰</h2>
    <div class="grid2">
      <div><label>XYã‚«ãƒ  Rmin (mm)</label><input id="RxyMin" type="number" value="39" step="1"></div>
      <div><label>XYã‚«ãƒ  Rmax (mm)</label><input id="RxyMax" type="number" value="60" step="1"></div>
      <div><label>Zã‚«ãƒ  Rmin (mm)</label><input id="RzMin" type="number" value="30" step="1"></div>
      <div><label>Zã‚«ãƒ  Rmax (mm)</label><input id="RzMax" type="number" value="40" step="1"></div>
      <div><label>å¹³æ»‘åŒ–ï¼ˆç§»å‹•å¹³å‡ï¼‰çª“(ç‚¹)</label><input id="smoothWin" type="number" value="9" step="2"></div>
      <div class="row" style="align-self:end; gap:6px;">
        <label style="margin:0;">å¹³æ»‘åŒ–ON</label>
        <input id="smoothOn" type="checkbox" checked>
      </div>
    </div>

    <div class="row" style="margin-top:10px;">
      <button class="primary" id="recalc">å†è¨ˆç®—</button>
      <button class="primary" id="play">â–¶ å†ç”Ÿ</button>
      <button id="pause">â¸ åœæ­¢</button>
    </div>
    <div class="kpi" id="kpi" style="margin-top:8px;">â€”</div>

    <h2 style="margin-top:12px;">PNGå‡ºåŠ›</h2>
    <div class="row">
      <button id="dlPngDraw">å®Œæˆå›³PNG</button>
      <button id="dlPngA">Î±ã‚«ãƒ PNG</button>
      <button id="dlPngB">Î²ã‚«ãƒ PNG</button>
      <button id="dlPngZ">Zã‚«ãƒ PNG</button>
    </div>
    <div class="small">â€» iOSã¯ä¿å­˜å…ˆãŒã€Œãƒ•ã‚¡ã‚¤ãƒ«ã€ã«ãªã£ãŸã‚Šã€Œå†™çœŸã€ã«ãªã£ãŸã‚Šã—ã¾ã™ã€‚å‡ºãªã„å ´åˆã¯é•·æŠ¼ã—ã§ä¿å­˜ã—ã¦ã­ã€‚</div>
  </section>

  <section class="card">
    <h2>ã‚¢ãƒ¼ãƒ ï¼‹è»Œè·¡ï¼ˆã‚¢ãƒ‹ãƒ¡ï¼‰</h2>
    <div class="canvasWrap"><canvas id="anim" width="900" height="1200"></canvas></div>
    <div class="small">ç‚¹ç·šï¼ç›®æ¨™ï¼ˆãƒšãƒ³ONåŒºé–“ã®ã¿ï¼‰ã€å®Ÿç·šï¼å®Ÿéš›ã®ãƒšãƒ³è»Œè·¡ï¼ˆãƒšãƒ³ONã®ã¿ï¼‰ã€‚åŸç‚¹(0,0)ã¯å°»å°¾ä»˜ã‘æ ¹ã€‚</div>

    <div class="three" style="margin-top:10px;">
      <div class="card" style="padding:8px;">
        <h2 style="margin-bottom:6px;">Î±ã‚«ãƒ </h2>
        <div class="canvasWrap" style="aspect-ratio:1/1;"><canvas id="camA" width="900" height="900"></canvas></div>
      </div>
      <div class="card" style="padding:8px;">
        <h2 style="margin-bottom:6px;">Î²ã‚«ãƒ </h2>
        <div class="canvasWrap" style="aspect-ratio:1/1;"><canvas id="camB" width="900" height="900"></canvas></div>
      </div>
      <div class="card" style="padding:8px;">
        <h2 style="margin-bottom:6px;">Zã‚«ãƒ ï¼ˆå†…å´ã®ã¿æƒ³å®šï¼‰</h2>
        <div class="canvasWrap" style="aspect-ratio:1/1;"><canvas id="camZ" width="900" height="900"></canvas></div>
      </div>
    </div>
  </section>
</div>

<script>
const TAU = Math.PI*2;
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const lerp = (a,b,t)=>a+(b-a)*t;

const el = {
  strokes: document.getElementById('strokes'),
  l: document.getElementById('l'),
  x0: document.getElementById('x0'),
  y0: document.getElementById('y0'),
  N: document.getElementById('N'),
  zStroke: document.getElementById('zStroke'),
  waitDeg: document.getElementById('waitDeg'),
  zUpDeg: document.getElementById('zUpDeg'),
  zDownDeg: document.getElementById('zDownDeg'),
  RxyMin: document.getElementById('RxyMin'),
  RxyMax: document.getElementById('RxyMax'),
  RzMin: document.getElementById('RzMin'),
  RzMax: document.getElementById('RzMax'),
  smoothWin: document.getElementById('smoothWin'),
  smoothOn: document.getElementById('smoothOn'),
  kpi: document.getElementById('kpi'),
  anim: document.getElementById('anim'),
  camA: document.getElementById('camA'),
  camB: document.getElementById('camB'),
  camZ: document.getElementById('camZ'),
};

function parseStrokes(text){
  const lines = text.split(/\\r?\\n/);
  const strokes = [];
  let cur = [];
  for(const ln of lines){
    const s = ln.trim();
    if(!s){
      if(cur.length>=2) strokes.push(cur);
      cur=[];
      continue;
    }
    const m = s.split(',').map(v=>+v.trim());
    if(m.length===2 && Number.isFinite(m[0]) && Number.isFinite(m[1])) cur.push([m[0],m[1]]);
  }
  if(cur.length>=2) strokes.push(cur);
  return strokes;
}

function polyLength(poly){
  let L=0;
  for(let i=1;i<poly.length;i++){
    const dx=poly[i][0]-poly[i-1][0];
    const dy=poly[i][1]-poly[i-1][1];
    L += Math.hypot(dx,dy);
  }
  return L;
}

function resamplePolyline(poly, n){
  const seg = [];
  let total=0;
  for(let i=1;i<poly.length;i++){
    const p=poly[i-1], q=poly[i];
    const d=Math.hypot(q[0]-p[0], q[1]-p[1]);
    seg.push(d); total+=d;
  }
  if(total===0) return Array.from({length:n}, ()=>poly[0].slice());
  const out=[poly[0].slice()];
  let distStep = total/(n-1);
  let acc=0, i=0;
  let nextTarget = distStep;
  while(out.length<n-1){
    const q = poly[i+1];
    const d = seg[i];
    if(acc + d >= nextTarget){
      const t = (nextTarget-acc)/d;
      out.push([ lerp(poly[i][0], q[0], t), lerp(poly[i][1], q[1], t) ]);
      nextTarget += distStep;
    }else{
      acc += d; i++;
      if(i>=seg.length) break;
    }
  }
  out.push(poly[poly.length-1].slice());
  return out;
}

function smoothCircular(arr, win){
  win = Math.max(1, Math.floor(win));
  if(win<=1) return arr.slice();
  const n=arr.length;
  const half=Math.floor(win/2);
  const out=new Array(n).fill(0);
  for(let i=0;i<n;i++){
    let s=0;
    for(let k=-half;k<=half;k++){
      s += arr[(i+k+n)%n];
    }
    out[i] = s/(2*half+1);
  }
  return out;
}

function unwrap(arr){
  const out=arr.slice();
  for(let pass=0; pass<2; pass++){
    for(let i=1;i<out.length;i++){
      let d=out[i]-out[i-1];
      if(d>Math.PI) out[i]-=TAU;
      if(d<-Math.PI) out[i]+=TAU;
    }
  }
  return out;
}

function buildCycle(strokes, N, params){
  const {x0,y0, waitDeg, zUpDeg, zDownDeg, zStroke} = params;
  const waitSteps = Math.max(1, Math.round(N * (waitDeg/360)));
  const upSteps   = Math.max(1, Math.round(N * (zUpDeg/360)));
  const downSteps = Math.max(1, Math.round(N * (zDownDeg/360)));

  const strokeResampled = strokes.map(st=>{
    const L = polyLength(st);
    const k = Math.max(20, Math.round(L)); // ~1pt per mm, min 20
    return resamplePolyline(st, k);
  });

  let home = null, best = 1e18;
  for(const st of strokeResampled){
    for(const p of st){
      const x=p[0]+x0, y=p[1]+y0;
      const r=x*x+y*y;
      if(r<best){ best=r; home=[x,y]; }
    }
  }
  if(!home) home=[x0,y0];

  const segments = [];
  segments.push({ z:0, pts: Array.from({length:waitSteps}, ()=>home) });

  for(let si=0; si<strokeResampled.length; si++){
    const st = strokeResampled[si].map(p=>[p[0]+x0, p[1]+y0]);
    const start = st[0], end = st[st.length-1];

    const prev = segments[segments.length-1].pts.slice(-1)[0];
    const dTravel = Math.hypot(start[0]-prev[0], start[1]-prev[1]);
    if(dTravel > 1e-6){
      const travelPts = resamplePolyline([prev, start], Math.max(5, Math.round(dTravel)));
      segments.push({ z:0, pts: travelPts });
    }

    segments.push({ z:"rampUp", pts: Array.from({length:upSteps}, ()=>start) });
    segments.push({ z:1, pts: st });
    segments.push({ z:"rampDown", pts: Array.from({length:downSteps}, ()=>end) });
  }

  const last = segments[segments.length-1].pts.slice(-1)[0];
  const dBack = Math.hypot(home[0]-last[0], home[1]-last[1]);
  if(dBack > 1e-6){
    const backPts = resamplePolyline([last, home], Math.max(5, Math.round(dBack)));
    segments.push({ z:0, pts: backPts });
  }

  const flatPts = [];
  const flatZ = [];

  function pushRun(pts, zMode){
    if(zMode===0 || zMode===1){
      for(const p of pts){ flatPts.push(p); flatZ.push(zMode*zStroke); }
    }else if(zMode==="rampUp"){
      const m = pts.length;
      for(let i=0;i<m;i++){
        const t=i/(m-1 || 1);
        flatPts.push(pts[i]);
        flatZ.push(t*zStroke);
      }
    }else if(zMode==="rampDown"){
      const m = pts.length;
      for(let i=0;i<m;i++){
        const t=i/(m-1 || 1);
        flatPts.push(pts[i]);
        flatZ.push((1-t)*zStroke);
      }
    }
  }
  for(const seg of segments) pushRun(seg.pts, seg.z);

  const M = flatPts.length;
  const ptsOut = [];
  const zOut = [];
  for(let i=0;i<N;i++){
    const t = (i/(N-1))*(M-1);
    const k = Math.floor(t);
    const f = t-k;
    const k2 = Math.min(M-1, k+1);
    const x = lerp(flatPts[k][0], flatPts[k2][0], f);
    const y = lerp(flatPts[k][1], flatPts[k2][1], f);
    const z = lerp(flatZ[k], flatZ[k2], f);
    ptsOut.push([x,y]);
    zOut.push(z);
  }

  return {pts: ptsOut, z: zOut, home};
}

let state = null;

function computeAll(){
  const strokes = parseStrokes(el.strokes.value);
  const l = +el.l.value;
  const x0 = +el.x0.value;
  const y0 = +el.y0.value;
  const N = Math.max(240, Math.floor(+el.N.value));
  const zStroke = +el.zStroke.value;
  const waitDeg = +el.waitDeg.value;
  const zUpDeg  = +el.zUpDeg.value;
  const zDownDeg= +el.zDownDeg.value;

  const RxyMin = +el.RxyMin.value, RxyMax = +el.RxyMax.value;
  const RzMin  = +el.RzMin.value,  RzMax  = +el.RzMax.value;

  const smoothOn = el.smoothOn.checked;
  const smoothWin = Math.max(1, Math.floor(+el.smoothWin.value));

  if(strokes.length===0){
    alert("ç·šæ–‡ãŒç©ºã§ã™ã€‚ã‚µãƒ³ãƒ—ãƒ«ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã‹ã€x,yã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚");
    return;
  }

  const cycle = buildCycle(strokes, N, {x0,y0,zStroke,waitDeg,zUpDeg,zDownDeg});
  const M = cycle.pts;
  const z = cycle.z;

  const alpha = new Array(N);
  const beta  = new Array(N);
  const A = new Array(N);
  const B = new Array(N);
  let minAy=1e9, minBy=1e9, maxReach=-1e9;

  for(let i=0;i<N;i++){
    const x=M[i][0], yM=M[i][1];
    const rho = Math.hypot(x,yM);
    maxReach = Math.max(maxReach, rho);
    const phi = Math.atan2(yM,x);
    const rhoC = Math.min(rho, 2*l-1e-6);
    const gamma = Math.acos(rhoC/(2*l));
    const a = phi + gamma;
    const b = phi - gamma;
    alpha[i]=a; beta[i]=b;
    const Ax=l*Math.cos(a), Ay=l*Math.sin(a);
    const Bx=l*Math.cos(b), By=l*Math.sin(b);
    A[i]=[Ax,Ay]; B[i]=[Bx,By];
    minAy = Math.min(minAy, Ay);
    minBy = Math.min(minBy, By);
  }

  const au = unwrap(alpha);
  const bu = unwrap(beta);

  function mapToRadius(u, rmin, rmax){
    let mn=1e9, mx=-1e9;
    for(const v of u){ mn=Math.min(mn,v); mx=Math.max(mx,v); }
    const out = u.map(v=>{
      const t = (v-mn)/(mx-mn || 1);
      return rmin + (rmax-rmin)*t;
    });
    return {out, mn, mx};
  }
  const Amap = mapToRadius(au, RxyMin, RxyMax);
  const Bmap = mapToRadius(bu, RxyMin, RxyMax);

  let Ra = Amap.out, Rb = Bmap.out;
  if(smoothOn){
    Ra = smoothCircular(Ra, smoothWin);
    Rb = smoothCircular(Rb, smoothWin);
  }

  let Rz = z.map(v=>{
    const t = clamp(v/(zStroke || 1), 0, 1);
    return RzMin + (RzMax-RzMin)*t;
  });
  if(smoothOn) Rz = smoothCircular(Rz, smoothWin);

  state = {
    N, l, M, z, A, B, alpha:au, beta:bu,
    Ra, Rb, Rz,
    RxyMin, RxyMax, RzMin, RzMax,
    home: cycle.home,
    stats: {
      minAy, minBy, maxReach,
      alphaMin:Amap.mn, alphaMax:Amap.mx,
      betaMin:Bmap.mn,  betaMax:Bmap.mx,
      zMin:Math.min(...z), zMax:Math.max(...z)
    }
  };

  tIndex = 0;
  renderAll();
}

function worldToCanvas(x,y, box, W,H){
  const px = (x-box.xmin)/(box.xmax-box.xmin)*W;
  const py = H - (y-box.ymin)/(box.ymax-box.ymin)*H;
  return [px,py];
}

function renderAnimFrame(){
  const c = el.anim, ctx = c.getContext('2d');
  ctx.clearRect(0,0,c.width,c.height);

  const box = { xmin:-120, xmax:120, ymin:-10, ymax:220 };

  ctx.strokeStyle="rgba(255,255,255,0.06)";
  ctx.lineWidth=1;
  for(let gx=-120;gx<=120;gx+=20){
    const [x1,y1]=worldToCanvas(gx,box.ymin,box,c.width,c.height);
    const [x2,y2]=worldToCanvas(gx,box.ymax,box,c.width,c.height);
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  }
  for(let gy=-10;gy<=220;gy+=20){
    const [x1,y1]=worldToCanvas(box.xmin,gy,box,c.width,c.height);
    const [x2,y2]=worldToCanvas(box.xmax,gy,box,c.width,c.height);
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  }

  ctx.setLineDash([10,10]);
  ctx.strokeStyle="rgba(200,200,200,0.30)";
  ctx.lineWidth=2;
  ctx.beginPath();
  let started=false;
  for(let i=0;i<state.N;i++){
    if(state.z[i] <= 0.001) continue;
    const [x,y]=state.M[i];
    const [px,py]=worldToCanvas(x,y,box,c.width,c.height);
    if(!started){ ctx.moveTo(px,py); started=true; } else ctx.lineTo(px,py);
  }
  if(started) ctx.stroke();
  ctx.setLineDash([]);

  ctx.strokeStyle="rgba(125,211,252,0.95)";
  ctx.lineWidth=2;
  ctx.beginPath();
  started=false;
  for(let i=0;i<=tIndex;i++){
    if(state.z[i] <= 0.001) continue;
    const [x,y]=state.M[i];
    const [px,py]=worldToCanvas(x,y,box,c.width,c.height);
    if(!started){ ctx.moveTo(px,py); started=true; } else ctx.lineTo(px,py);
  }
  if(started) ctx.stroke();

  const O=[0,0];
  const A=state.A[tIndex], B=state.B[tIndex], M=state.M[tIndex];
  function drawSeg(p,q,color){
    ctx.strokeStyle=color; ctx.lineWidth=5;
    const [px,py]=worldToCanvas(p[0],p[1],box,c.width,c.height);
    const [qx,qy]=worldToCanvas(q[0],q[1],box,c.width,c.height);
    ctx.beginPath(); ctx.moveTo(px,py); ctx.lineTo(qx,qy); ctx.stroke();
  }
  drawSeg(O,A,"#60a5fa");
  drawSeg(O,B,"#fb923c");
  drawSeg(A,M,"#22c55e");
  drawSeg(B,M,"#ef4444");

  function dot(p,color){
    const [px,py]=worldToCanvas(p[0],p[1],box,c.width,c.height);
    ctx.fillStyle=color;
    ctx.beginPath(); ctx.arc(px,py,8,0,TAU); ctx.fill();
  }
  dot(O,"#b45309"); dot(A,"#60a5fa"); dot(B,"#fb923c"); dot(M, state.z[tIndex]>0.001 ? "#f43f5e" : "rgba(244,63,94,0.35)");

  ctx.fillStyle="rgba(255,255,255,0.85)";
  ctx.font="18px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
  const deg = v => (v*180/Math.PI).toFixed(1);
  const zmm = state.z[tIndex].toFixed(1);
  ctx.fillText(`Î±=${deg(state.alpha[tIndex])}Â°  Î²=${deg(state.beta[tIndex])}Â°  Z=${zmm}mm`, 18, 32);
}

function renderCam(canvas, R, rmin, rmax){
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const margin=24;
  const scale=(canvas.width/2 - margin)/(rmax);
  const cx=canvas.width/2, cy=canvas.height/2;

  const toXY=(r,th)=>[cx + r*Math.cos(th)*scale, cy - r*Math.sin(th)*scale];

  ctx.strokeStyle="rgba(255,255,255,0.08)"; ctx.lineWidth=2;
  for(const rr of [rmin, (rmin+rmax)/2, rmax]){
    ctx.beginPath();
    ctx.arc(cx,cy,rr*scale,0,TAU);
    ctx.stroke();
  }

  ctx.strokeStyle="rgba(125,211,252,0.95)";
  ctx.lineWidth=4;
  ctx.beginPath();
  for(let i=0;i<R.length;i++){
    const th = TAU*i/R.length;
    const [x,y]=toXY(R[i], th);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.closePath(); ctx.stroke();

  ctx.fillStyle="rgba(255,255,255,0.85)";
  ctx.beginPath(); ctx.arc(cx,cy,3,0,TAU); ctx.fill();
  ctx.strokeStyle="rgba(255,255,255,0.65)";
  ctx.lineWidth=2;
  ctx.beginPath(); ctx.arc(cx,cy,12,0,TAU); ctx.stroke();
}

function renderAll(){
  renderAnimFrame();
  renderCam(el.camA, state.Ra, state.RxyMin, state.RxyMax);
  renderCam(el.camB, state.Rb, state.RxyMin, state.RxyMax);
  renderCam(el.camZ, state.Rz, state.RzMin,  state.RzMax);

  const s=state.stats;
  const deg=v=>v*180/Math.PI;
  el.kpi.textContent =
    `min(Ay)=${s.minAy.toFixed(1)}mm  min(By)=${s.minBy.toFixed(1)}mm  `+
    `max|OM|=${s.maxReach.toFixed(1)}mm  `+
    `Î±=${deg(s.alphaMin).toFixed(1)}..${deg(s.alphaMax).toFixed(1)}Â°  `+
    `Î²=${deg(s.betaMin).toFixed(1)}..${deg(s.betaMax).toFixed(1)}Â°  `+
    `Z=${s.zMin.toFixed(1)}..${s.zMax.toFixed(1)}mm`;
}

let playing=false;
let tIndex=0;
let raf=null;

function tick(){
  if(!playing) return;
  tIndex = (tIndex+1) % state.N;
  renderAnimFrame();
  raf = requestAnimationFrame(tick);
}

document.getElementById('play').addEventListener('click', ()=>{
  if(!state) computeAll();
  playing=true;
  if(raf) cancelAnimationFrame(raf);
  raf = requestAnimationFrame(tick);
});
document.getElementById('pause').addEventListener('click', ()=>{
  playing=false;
  if(raf) cancelAnimationFrame(raf);
  raf=null;
});
document.getElementById('recalc').addEventListener('click', ()=>{
  playing=false;
  if(raf) cancelAnimationFrame(raf);
  raf=null;
  computeAll();
});

function downloadCanvasPNG(canvas, filename){
  const url = canvas.toDataURL("image/png");
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
}

document.getElementById('dlPngDraw').addEventListener('click', ()=>{
  if(!state) return;
  const W=1200, H=1200;
  const tmp=document.createElement('canvas');
  tmp.width=W; tmp.height=H;
  const ctx=tmp.getContext('2d');
  ctx.fillStyle="white"; ctx.fillRect(0,0,W,H);

  let xmin=1e9,xmax=-1e9,ymin=1e9,ymax=-1e9;
  for(let i=0;i<state.N;i++){
    if(state.z[i] <= 0.001) continue;
    const [x,y]=state.M[i];
    xmin=Math.min(xmin,x); xmax=Math.max(xmax,x);
    ymin=Math.min(ymin,y); ymax=Math.max(ymax,y);
  }
  const pad=20;
  if(!(xmin<xmax && ymin<ymax)){ xmin=-50;xmax=50;ymin=-50;ymax=50; }
  xmin-=pad; ymin-=pad; xmax+=pad; ymax+=pad;
  const box={xmin,xmax,ymin,ymax};

  ctx.strokeStyle="black"; ctx.lineWidth=2;
  ctx.beginPath();
  let started=false;
  for(let i=0;i<state.N;i++){
    if(state.z[i] <= 0.001) continue;
    const [x,y]=state.M[i];
    const [px,py]=worldToCanvas(x,y,box,W,H);
    if(!started){ ctx.moveTo(px,py); started=true; } else ctx.lineTo(px,py);
  }
  if(started) ctx.stroke();

  downloadCanvasPNG(tmp, "final_drawing.png");
});

document.getElementById('dlPngA').addEventListener('click', ()=>downloadCanvasPNG(el.camA, "cam_alpha.png"));
document.getElementById('dlPngB').addEventListener('click', ()=>downloadCanvasPNG(el.camB, "cam_beta.png"));
document.getElementById('dlPngZ').addEventListener('click', ()=>downloadCanvasPNG(el.camZ, "cam_z.png"));

// samples
function setText(t){ el.strokes.value=t; }
document.getElementById('loadSquare').addEventListener('click', ()=>{
  const a=37.5;
  const pts=[];
  const corners=[[ -a,-a],[a,-a],[a,a],[-a,a],[-a,-a]];
  for(const p of corners) pts.push(p.join(","));
  pts.push("");
  const b=25;
  const corners2=[[ -b,-b],[b,-b],[b,b],[-b,b],[-b,-b]];
  for(const p of corners2) pts.push(p.join(","));
  setText(pts.join("\\n"));
  computeAll(); renderAll();
});
document.getElementById('loadStar').addEventListener('click', ()=>{
  const pts=[];
  const Rout=40, Rin=18, k=5, N=200;
  for(let i=0;i<=N;i++){
    const th=TAU*i/N;
    const rho = Rin + (Rout-Rin)*0.5*(1+Math.cos(k*th));
    pts.push([rho*Math.cos(th), rho*Math.sin(th)].map(v=>v.toFixed(2)).join(","));
  }
  setText(pts.join("\\n"));
  computeAll(); renderAll();
});
document.getElementById('loadHilbert').addEventListener('click', ()=>{
  const pts=[];
  const s=70;
  const path=[
    [-s/2,-s/2],[-s/2,s/2],[0,s/2],[0,0],[s/2,0],[s/2,s/2],
    [s/2,-s/2],[0,-s/2],[0,0],[-s/2,0],[-s/2,-s/2]
  ];
  for(const p of path) pts.push(p.join(","));
  setText(pts.join("\\n"));
  computeAll(); renderAll();
});

document.getElementById('loadSquare').click();
</script>
</body>
</html>
