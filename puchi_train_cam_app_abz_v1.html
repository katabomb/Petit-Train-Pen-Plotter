<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>プチ電車ペンプロッタ2｜αβZデータ→3カム生成</title>
<style>
  :root{--bg:#fff;--fg:#111;--muted:#555;--line:#ddd;--blue:#1463ff;--gray:#888;}
  body{margin:0;font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto;color:var(--fg);background:var(--bg);}
  header{padding:10px 12px;border-bottom:1px solid var(--line);display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  header h1{font-size:14px;margin:0 12px 0 0}
  .wrap{display:grid;grid-template-columns: 360px 1fr;gap:12px;padding:12px;align-items:start}
  .card{border:1px solid var(--line);border-radius:10px;padding:10px;background:#fff}
  .card h2{font-size:13px;margin:0 0 8px 0}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  label{font-size:12px;color:var(--muted);display:flex;gap:6px;align-items:center}
  input,select,button,textarea{font:inherit}
  input[type="number"]{width:86px}
  textarea{width:100%;height:220px;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:12px}
  button{border:1px solid var(--line);background:#f7f7f7;border-radius:8px;padding:8px 10px;cursor:pointer}
  button:hover{background:#f0f0f0}
  .hint{font-size:12px;color:var(--muted);line-height:1.4}
  .grid2{display:grid;grid-template-columns: 1fr 1fr;gap:12px}
  canvas{display:block;max-width:100%;height:auto;background:#fff}
  .small{font-size:12px;color:var(--muted)}
</style>
</head>
<body>
<header>
  <h1>αβZデータ → 3カム生成（α / β / Z）</h1>
  <button id="btnSampleSquare">サンプル（正方形）</button>
  <button id="btnSampleStar">サンプル（星）</button>
  <button id="btnRecalc">再計算</button>
  <button id="btnPlay">再生</button>
  <button id="btnPause">停止</button>
</header>

<div class="wrap">
  <div class="card">
    <h2>入力（α,β,z）</h2>
    <div class="hint">1行＝ <b>α,β,z</b>（度,度,0/1）。行数は自由（360推奨）。<br>このアプリ内部で「Z切替時にαβ停止」を自動挿入し、360点に正規化します。</div>
    <textarea id="ta"></textarea>
    <div class="row" style="margin-top:8px">
      <label>アーム長 l(mm) <input type="number" id="lArm" value="90" step="1"></label>
      <label>外周半径 Router(mm) <input type="number" id="rOuter" value="70" step="1"></label>
      <label>中心穴(半径mm) <input type="number" id="rHole" value="2.5" step="0.1"></label>
    </div>
    <div class="row" style="margin-top:6px">
      <label>α cam r(min,max) <input type="number" id="aMin" value="32" step="1"> <input type="number" id="aMax" value="60" step="1"></label>
      <label>β cam r(min,max) <input type="number" id="bMin" value="32" step="1"> <input type="number" id="bMax" value="60" step="1"></label>
      <label>Z cam r(min,max) <input type="number" id="zMin" value="50" step="1"> <input type="number" id="zMax" value="60" step="1"></label>
    </div>
    <div class="row" style="margin-top:6px">
      <label>Z 上下速度比（上:下）
        <select id="zRatio">
          <option value="7:3" selected>7:3</option>
          <option value="6:4">6:4</option>
          <option value="5:5">5:5</option>
        </select>
      </label>
      <label>Z切替に割り当てる最小角(°) <input type="number" id="zMinDeg" value="8" step="1"></label>
      <label>待機余白(%) <input type="number" id="idlePct" value="10" step="1"></label>
    </div>
    <div class="row" style="margin-top:8px">
      <button id="btnPngA">PNG保存 αカム</button>
      <button id="btnPngB">PNG保存 βカム</button>
      <button id="btnPngZ">PNG保存 Zカム</button>
      <button id="btnPngAll">PNG保存 3枚</button>
    </div>
    <div class="small" style="margin-top:6px">※ “向きマーク”は 0°方向（右向き）に短い線を入れています。</div>
  </div>

  <div class="grid2">
    <div class="card">
      <h2>リンク機構アニメ（ペン軌跡）</h2>
      <canvas id="cvAnim" width="520" height="520"></canvas>
      <div class="hint">青=描画(z=1)、灰=移動(z=0)。</div>
    </div>
    <div class="card">
      <h2>カム形状（3枚プレビュー）</h2>
      <div class="grid2">
        <div><canvas id="cvA" width="360" height="360"></canvas><div class="small" style="text-align:center">α</div></div>
        <div><canvas id="cvB" width="360" height="360"></canvas><div class="small" style="text-align:center">β</div></div>
        <div style="grid-column:1 / span 2"><canvas id="cvZ" width="740" height="360"></canvas><div class="small" style="text-align:center">Z</div></div>
      </div>
    </div>
  </div>
</div>

<script>
// ---------- utilities ----------
const TA = document.getElementById('ta');
const $ = (id)=>document.getElementById(id);
function clamp(x,a,b){return Math.max(a,Math.min(b,x));}
function lerp(a,b,t){return a+(b-a)*t;}
function norm360(d){ let w=d%360; if(w<0) w+=360; return w; }
function unwrap(prev, cur){
  // cur is in [0,360) or any; return value near prev
  if(!Number.isFinite(prev)) return cur;
  let w=cur;
  while(w-prev>180) w-=360;
  while(w-prev<-180) w+=360;
  return w;
}
function parseRatio(s){
  const m=s.split(':');
  const a=parseFloat(m[0]||'1'), b=parseFloat(m[1]||'1');
  const sum=a+b;
  return {up:a/sum, down:b/sum};
}

// ---------- samples ----------
function sampleSquare(){
  // simple square-ish loop in αβz (draw then idle)
  const N=360;
  let lines=[];
  for(let i=0;i<N;i++){
    // create square in XY then IK analytically? We'll just approximate with known "perfect" profile:
    // α swings ~66°, β swings ~66° out of phase to draw square-ish.
    const t=i/N;
    const phase = t*4;
    const s = phase%1;
    const edge = Math.floor(phase);
    // XY square centered around (0, sqrt2*l) feel by using angles near 45/135 and modulating
    const baseA=45, baseB=135;
    let da=0, db=0;
    const amp=33; // total swing ~66
    if(edge===0){ da=lerp(-amp, amp, s); db=lerp( amp, amp, s); }
    if(edge===1){ da=lerp( amp, amp, s); db=lerp( amp,-amp, s); }
    if(edge===2){ da=lerp( amp,-amp, s); db=lerp(-amp,-amp, s); }
    if(edge===3){ da=lerp(-amp,-amp, s); db=lerp(-amp, amp, s); }
    const z = (i<320)?1:0; // idle tail
    lines.push(`${norm360(baseA+da).toFixed(2)},${norm360(baseB+db).toFixed(2)},${z}`);
  }
  return lines.join("\n");
}
function sampleStar(){
  const N=360;
  let lines=[];
  const baseA=45, baseB=135;
  for(let i=0;i<N;i++){
    const t=i/N;
    const w=Math.sin(2*Math.PI*5*t); // 5 points
    const u=Math.cos(2*Math.PI*3*t);
    const amp=28;
    const a=norm360(baseA + amp*w);
    const b=norm360(baseB + amp*u);
    const z = (i<330)?1:0;
    lines.push(`${a.toFixed(2)},${b.toFixed(2)},${z}`);
  }
  return lines.join("\n");
}

// ---------- core: normalize αβz to 360 with Z-stop insertion ----------
function parseABZ(text){
  const rows=[];
  const lines=text.split(/\r?\n/);
  for(const ln of lines){
    const s=ln.trim();
    if(!s) continue;
    const parts=s.split(/[\s,]+/).filter(Boolean);
    if(parts.length<3) continue;
    const A=parseFloat(parts[0]), B=parseFloat(parts[1]), Z=parseInt(parts[2],10);
    if(!Number.isFinite(A)||!Number.isFinite(B)) continue;
    rows.push({A:norm360(A), B:norm360(B), Z:(Z?1:0)});
  }
  return rows;
}

function expandWithZStops(rows){
  // Two-stage: XY move first (Z stays prev), then if Z changes, insert Z event holding A,B.
  if(rows.length<2) return rows.slice();
  const out=[];
  let prev = rows[0];
  out.push({A:prev.A,B:prev.B,Z:prev.Z, kind:"xy"});
  for(let i=1;i<rows.length;i++){
    const cur=rows[i];
    // XY event (Z stays prev.Z)
    out.push({A:cur.A,B:cur.B,Z:prev.Z, kind:"xy"});
    // Z event if changed
    if(cur.Z!==prev.Z){
      out.push({A:cur.A,B:cur.B,Z:cur.Z, kind:"z"});
    }
    prev=cur;
  }
  // loop closure: ensure smooth by considering last->first Z change? We'll ignore; user can add if needed.
  return out;
}

function buildWeightedSamples(events, N, zMinDeg, zRatioUpDown, idlePct){
  // Allocate N samples over events proportionally to "difficulty". Keep idlePct at end as Z=0 and XY hold.
  const idleN = Math.max(0, Math.round(N * (clamp(idlePct,0,50)/100)));
  const mainN = Math.max(10, N - idleN);

  // compute weights per event segment (between consecutive events)
  const segs=[];
  let prevA=NaN, prevB=NaN, prevZ=events[0]?.Z ?? 0;
  for(let i=0;i<events.length;i++){
    const e=events[i];
    const A=unwrap(prevA, e.A);
    const B=unwrap(prevB, e.B);
    const dA = Number.isFinite(prevA)? Math.abs(A-prevA):0;
    const dB = Number.isFinite(prevB)? Math.abs(B-prevB):0;
    let w = 0.1 + (dA+dB)*0.02; // base + scaled degrees
    if(e.kind==="z"){
      // ensure minimum effort for Z transitions; up slower than down
      const up = (prevZ===0 && e.Z===1);
      const ratio = up ? zRatioUpDown.up : zRatioUpDown.down;
      w += (zMinDeg/5) * (ratio/0.5);
    }
    segs.push({A, B, Z:e.Z, kind:e.kind, w});
    prevA=A; prevB=B; prevZ=e.Z;
  }

  // normalize weights to mainN points
  const totalW = segs.reduce((s,x)=>s+x.w,0) || 1;
  // cumulative distribution for sampling
  const cum=[];
  let acc=0;
  for(const s of segs){ acc += s.w; cum.push(acc/totalW); }

  const samples=[];
  let idx=0;
  for(let k=0;k<mainN;k++){
    const u = (k/(mainN-1));
    while(idx<cum.length-1 && cum[idx] < u) idx++;
    const s = segs[idx];
    samples.push({A:norm360(s.A), B:norm360(s.B), Z:s.Z});
  }

  // Idle tail: hold last A,B; force Z=0 (paper down away) for safety
  if(idleN>0){
    const last = samples[samples.length-1] || {A:0,B:0,Z:0};
    for(let i=0;i<idleN;i++){
      samples.push({A:last.A,B:last.B,Z:0});
    }
  }
  // trim/pad
  while(samples.length>N) samples.pop();
  while(samples.length<N){
    const last=samples[samples.length-1]||{A:0,B:0,Z:0};
    samples.push({...last});
  }
  return samples;
}

// ---------- forward kinematics ----------
function penXY(Adeg, Bdeg, l){
  const a = Adeg*Math.PI/180;
  const b = Bdeg*Math.PI/180;
  const Ax = l*Math.cos(a), Ay = l*Math.sin(a);
  const Bx = l*Math.cos(b), By = l*Math.sin(b);
  return {x:Ax+Bx, y:Ay+By, Ax, Ay, Bx, By};
}

// ---------- cam mapping ----------
function mapToRadius(valuesUnwrapped, rMin, rMax){
  let mn=Infinity, mx=-Infinity;
  for(const v of valuesUnwrapped){ mn=Math.min(mn,v); mx=Math.max(mx,v); }
  if(!Number.isFinite(mn) || !Number.isFinite(mx) || mx-mn<1e-9){
    return valuesUnwrapped.map(_=> (rMin+rMax)/2);
  }
  return valuesUnwrapped.map(v=> rMin + ( (v-mn)/(mx-mn) )*(rMax-rMin) );
}

function camFromAngles(samples, key, rMin, rMax){
  // unwrap for smooth cam then map to radii
  const un=[];
  let prev=NaN;
  for(const s of samples){
    const v = s[key];
    const u = unwrap(prev, v);
    un.push(u);
    prev=u;
  }
  return mapToRadius(un, rMin, rMax);
}

function camFromZ(samples, rMin, rMax){
  // z is 0/1; we still smooth by simple moving average window
  const z = samples.map(s=>s.Z?1:0);
  const win=5;
  const zs=z.map((_,i)=>{
    let acc=0,c=0;
    for(let j=-win;j<=win;j++){
      const k=clamp(i+j,0,z.length-1);
      acc+=z[k]; c++;
    }
    return acc/c;
  });
  return zs.map(v=> rMin + v*(rMax-rMin));
}

// ---------- drawing cams ----------
function drawCam(canvas, radii, router, rhole, label){
  const ctx=canvas.getContext('2d');
  const W=canvas.width,H=canvas.height;
  ctx.clearRect(0,0,W,H);
  const cx=W/2, cy=H/2;
  const scale = Math.min(W,H) / (2*(router+8)); // padding
  function mmToPx(mm){ return mm*scale; }

  // background
  ctx.fillStyle="#fff"; ctx.fillRect(0,0,W,H);

  // outer circle
  ctx.strokeStyle="#bbb"; ctx.lineWidth=1;
  ctx.beginPath(); ctx.arc(cx,cy, mmToPx(router), 0, Math.PI*2); ctx.stroke();

  // direction mark at 0° (right)
  ctx.strokeStyle="#999";
  ctx.beginPath();
  ctx.moveTo(cx, cy);
  ctx.lineTo(cx+mmToPx(router), cy);
  ctx.stroke();

  // cam outline
  ctx.strokeStyle="#111"; ctx.lineWidth=2;
  ctx.beginPath();
  for(let i=0;i<radii.length;i++){
    const th = (i/radii.length)*Math.PI*2;
    const r = radii[i];
    const x = cx + mmToPx(r)*Math.cos(th);
    const y = cy + mmToPx(r)*Math.sin(th);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.closePath(); ctx.stroke();

  // center hole
  ctx.strokeStyle="#111"; ctx.lineWidth=2;
  ctx.beginPath(); ctx.arc(cx,cy, mmToPx(rhole), 0, Math.PI*2); ctx.stroke();

  // label
  ctx.fillStyle="#222";
  ctx.font="bold 18px system-ui";
  ctx.fillText(label, 10, 24);
}

function downloadPNG(canvas, filename){
  const a=document.createElement('a');
  a.download=filename;
  a.href=canvas.toDataURL('image/png');
  a.click();
}

// ---------- animation ----------
let state = {samples:[], l:90, t:0, playing:false, raf:0};
function drawAnim(){
  const cv=$('cvAnim');
  const ctx=cv.getContext('2d');
  const W=cv.width,H=cv.height;

  ctx.clearRect(0,0,W,H);
  ctx.fillStyle="#fff"; ctx.fillRect(0,0,W,H);

  const l=parseFloat($('lArm').value);
  const smp=state.samples;
  if(!smp.length){
    ctx.fillStyle="#444"; ctx.font="14px system-ui";
    ctx.fillText("データがありません（再計算）", 20, 30);
    return;
  }

  // ---- Forward kinematics for all samples ----
  const pts=smp.map(s=>penXY(s.A,s.B,l));

  // ---- Bounds: include origin and both elbow points too (so 4節リンク全体が必ず見える) ----
  let minx=Infinity,maxx=-Infinity,miny=Infinity,maxy=-Infinity;
  for(const p of pts){
    const xs=[0, p.Ax, p.Bx, p.x];
    const ys=[0, p.Ay, p.By, p.y];
    for(const x of xs){ minx=Math.min(minx,x); maxx=Math.max(maxx,x); }
    for(const y of ys){ miny=Math.min(miny,y); maxy=Math.max(maxy,y); }
  }

  // Safety margin (mm)
  const pad = Math.max(12, 0.18*Math.max(maxx-minx, maxy-miny));
  minx -= pad; maxx += pad;
  miny -= pad; maxy += pad;

  // IMPORTANT: if user wants the view a bit higher, keep a small upward pan here.
  // (Positive panY shifts everything up on screen by effectively moving the window downward in world coords.)
  const panY = 0.15 * (maxy-miny);  // tweakable; makes origin less "low"/cramped
  miny -= panY;
  maxy -= panY;

  const sx = W / (maxx-minx);
  const sy = H / (maxy-miny);
  const s  = Math.min(sx, sy);

  const ox = (W - (maxx-minx)*s)/2;
  const oy = (H - (maxy-miny)*s)/2;

  const tx = (x)=> ox + (x - minx)*s;
  const ty = (y)=> H - (oy + (y - miny)*s); // y up in world

  // ---- Trail ----
  ctx.lineWidth=2;
  for(let i=1;i<pts.length;i++){
    const p0=pts[i-1], p1=pts[i];
    const z = smp[i].Z;
    ctx.strokeStyle = z? "rgba(20,99,255,0.9)" : "rgba(140,140,140,0.7)";
    ctx.beginPath();
    ctx.moveTo(tx(p0.x), ty(p0.y));
    ctx.lineTo(tx(p1.x), ty(p1.y));
    ctx.stroke();
  }

  // ---- Current pose ----
  const idx = Math.floor(state.t) % smp.length;
  const cur = pts[idx];

  // origin
  ctx.fillStyle="#111";
  ctx.beginPath(); ctx.arc(tx(0), ty(0), 4, 0, Math.PI*2); ctx.fill();

  // arms (two 2-link chains sharing pen)
  ctx.strokeStyle="#111"; ctx.lineWidth=3;
  ctx.beginPath();
  ctx.moveTo(tx(0), ty(0));
  ctx.lineTo(tx(cur.Ax), ty(cur.Ay));
  ctx.lineTo(tx(cur.x),  ty(cur.y));
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(tx(0), ty(0));
  ctx.lineTo(tx(cur.Bx), ty(cur.By));
  ctx.lineTo(tx(cur.x),  ty(cur.y));
  ctx.stroke();

  // pen point
  ctx.fillStyle = smp[idx].Z? "#1463ff" : "#888";
  ctx.beginPath(); ctx.arc(tx(cur.x), ty(cur.y), 5, 0, Math.PI*2); ctx.fill();

  // text
  ctx.fillStyle="#333"; ctx.font="12px system-ui";
  ctx.fillText(`i=${idx}  α=${smp[idx].A.toFixed(1)}  β=${smp[idx].B.toFixed(1)}  z=${smp[idx].Z}`, 14, 18);
}

function tick(){
  if(!state.playing) return;
  state.t += 1; // 1 sample per frame
  drawAnim();
  state.raf = requestAnimationFrame(tick);
}

// ---------- recalc ----------
function recalc(){
  const rows=parseABZ(TA.value);
  const l=parseFloat($('lArm').value);
  const zMinDeg=parseFloat($('zMinDeg').value);
  const idlePct=parseFloat($('idlePct').value);
  const ratio=parseRatio($('zRatio').value);

  const ev=expandWithZStops(rows);
  const samples=buildWeightedSamples(ev, 360, zMinDeg, ratio, idlePct);

  state.samples=samples;
  state.t=0;

  // build cams
  const aR=camFromAngles(samples,'A', parseFloat($('aMin').value), parseFloat($('aMax').value));
  const bR=camFromAngles(samples,'B', parseFloat($('bMin').value), parseFloat($('bMax').value));
  const zR=camFromZ(samples, parseFloat($('zMin').value), parseFloat($('zMax').value));
  const router=parseFloat($('rOuter').value);
  const rhole=parseFloat($('rHole').value);

  drawCam($('cvA'), aR, router, rhole, "α");
  drawCam($('cvB'), bR, router, rhole, "β");
  // Z canvas is wide; still draw centered
  drawCam($('cvZ'), zR, router, rhole, "Z");

  drawAnim();
}

$('btnRecalc').addEventListener('click', recalc);
$('btnPlay').addEventListener('click', ()=>{
  if(!state.samples.length) recalc();
  state.playing=true;
  cancelAnimationFrame(state.raf);
  state.raf=requestAnimationFrame(tick);
});
$('btnPause').addEventListener('click', ()=>{
  state.playing=false;
  cancelAnimationFrame(state.raf);
});

$('btnSampleSquare').addEventListener('click', ()=>{ TA.value=sampleSquare(); recalc(); });
$('btnSampleStar').addEventListener('click', ()=>{ TA.value=sampleStar(); recalc(); });

$('btnPngA').addEventListener('click', ()=>downloadPNG($('cvA'), 'cam_alpha.png'));
$('btnPngB').addEventListener('click', ()=>downloadPNG($('cvB'), 'cam_beta.png'));
$('btnPngZ').addEventListener('click', ()=>downloadPNG($('cvZ'), 'cam_z.png'));
$('btnPngAll').addEventListener('click', ()=>{
  downloadPNG($('cvA'), 'cam_alpha.png');
  setTimeout(()=>downloadPNG($('cvB'), 'cam_beta.png'), 150);
  setTimeout(()=>downloadPNG($('cvZ'), 'cam_z.png'), 300);
});

// init
TA.value = sampleSquare();
recalc();
</script>
</body>
</html>
