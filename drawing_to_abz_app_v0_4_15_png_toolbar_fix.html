<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>お絵描き → αβz 出力（下絵・グリッド対応 v0.4.5）</title>
<style>
  body{font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto;margin:0;background:#fff;color:#111}
  .toolbar{display:flex;flex-wrap:wrap;gap:10px;padding:8px;border-bottom:1px solid #ccc;align-items:center}
  #wrap{display:flex;gap:12px;padding:8px;align-items:flex-start}
  #canvasWrap{position:relative;width:360px;height:360px}
  #canvasWrap canvas{position:absolute;left:0;top:0}
  #bg{z-index:0}
  #grid{z-index:1;pointer-events:none}
  #draw{z-index:2;border:1px solid #999;touch-action:none}
  #right{flex:1 1 auto;min-width:260px}
  textarea{width:100%;height:300px;font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace}
  label{font-size:12px;white-space:nowrap}
  .hint{font-size:12px;color:#444;padding:0 8px 8px}

  /* --- canvas position hotfix: shift down to match logical drawing area --- */
  .canvas-wrap {
    margin-top: 24px; /* visual shift only, no coordinate changes */
  }


  /* --- overlay stage for sketch/grid/canvas --- */
  .stage { position: relative; width: 360px; height: 360px; margin: 0 auto; }
  .stage canvas { position: absolute; left: 0; top: 0; }

</style>
</head>
<body>

<div class="toolbar">
<button onclick="exportPNG()">PNG保存</button>
  <label>下絵 <input type="file" id="bgFile" accept="image/*"></label>
  <label>透過 <input type="range" id="bgAlpha" min="0" max="1" step="0.05" value="0.30"></label>
  <label><input type="checkbox" id="gridOn" checked> グリッド</label>
  <label>l <input type="number" id="lArm" value="90" step="1" style="width:70px"> mm</label>
  <label>x0 <input type="number" id="x0Off" value="0" step="1" style="width:70px"> mm</label>
  <label>y0 <input type="number" id="y0Off" value="0" step="1" style="width:70px"> mm</label>
  <label>行数
    <select id="nRows">
      <option value="360" selected>360</option>
      <option value="720">720</option>
    </select>
  </label>
  <label><input type="checkbox" id="travelOn" checked> ストローク間は z=0 で移動</label>
  <button id="undoBtn">Undo</button>
  <button id="clearBtn">クリア</button>
</div>
<div class="hint">
  ペンを離すと「別ストローク」になります。ストローク間の移動は自動で z=0（ペン上げ）にできます。（原点はキャンバス下中央＝x=0,y=0）
</div>

<div id="wrap">
  <div id="canvasWrap"><div class="stage">
    <canvas id="bg" width="360" height="360"></canvas></div>
    <canvas id="grid" width="360" height="360"></canvas>
    <canvas id="draw" width="360" height="360"></canvas>
  </div></div>
  <div id="right">
    <textarea id="out" spellcheck="false"></textarea>
  </div>
</div>

<script>


  function drawSafeSquare75() {
    if (!window.worldToScreen || !window.getMappingParams) return;
    const gcv = document.getElementById("grid");
    if (!gcv) return;
    const gctx = gcv.getContext("2d");
    const { yC } = getMappingParams();
    const half = 75 / 2;
    const p1 = worldToScreen(-half, yC + half);
    const p2 = worldToScreen( half, yC - half);
    gctx.save();
    gctx.strokeStyle = "rgba(0,0,0,0.55)";
    gctx.lineWidth = 2;
    gctx.strokeRect(p1.px, p1.py, p2.px - p1.px, p2.py - p1.py);
    gctx.restore();
  }



  // --- DOM helper (restore) ---
  const $ = (id) => document.getElementById(id);


  // --- Unified coordinate mapping (single source of truth) ---
  // Screen(px) -> World(mm). World origin is at (0,0).
  // Constraint: distance from canvas center to origin is √2*l (matches cam generator)
  // Safety box: 75mm square should fit comfortably.
  function getMappingParams() {
    const cv = document.getElementById("bg");
    const W = cv ? cv.width : 360;
    const H = cv ? cv.height : 360;
    const l = parseFloat($('lArm')?.value || 90);
    const yC = Math.SQRT2 * l;          // world y at screen center
    const safePx = Math.min(W, H) * 0.72;  // 75mm occupies 72% of canvas
    const mmPerPx = 75 / safePx;
    return { W, H, l, yC, mmPerPx };
  }

  function screenToWorld(px, py) {
    const { W, H, yC, mmPerPx } = getMappingParams();
    const x = (px - W/2) * mmPerPx;
    const y = yC + (H/2 - py) * mmPerPx;
    return { x, y };
  }

  function worldToScreen(x, y) {
    const { W, H, yC, mmPerPx } = getMappingParams();
    const px = W/2 + x / mmPerPx;
    const py = H/2 - (y - yC) / mmPerPx;
    return { px, py };
  }

  const bg=document.getElementById('bg'), grid=document.getElementById('grid'), canvas=document.getElementById('draw');
  const bctx=bg.getContext('2d'), gctx=grid.getContext('2d'), ctx=canvas.getContext('2d');
  const out=document.getElementById('out');

  const travelOn=document.getElementById('travelOn');
  const gridOn=document.getElementById('gridOn');
  const lArm=document.getElementById('lArm');
  const x0Off=document.getElementById('x0Off');
  const y0Off=document.getElementById('y0Off');
  const nRows=document.getElementById('nRows');

  let strokes=[];

  let undoStack=[];
      // each stroke: [{x,y}...]
  let cur=null;
  let drawing=false;

  function redraw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.lineWidth=2;
    ctx.strokeStyle="#0066ff";
    ctx.lineJoin="round";
    ctx.lineCap="round";
    for(const s of strokes){
      if(!s || s.length<2) continue;
      ctx.beginPath();
      for(let i=0;i<s.length;i++){
        const p=s[i];
        if(i===0) ctx.moveTo(p.x,p.y);
        else ctx.lineTo(p.x,p.y);
      }
      ctx.stroke();
    }
  }

  function drawGrid(){
    gctx.clearRect(0,0,grid.width,grid.height);
    if(!gridOn.checked) return;
    gctx.strokeStyle="#ddd";
    for(let i=0;i<=360;i+=30){
      gctx.beginPath(); gctx.moveTo(i,0); gctx.lineTo(i,360); gctx.stroke();
      gctx.beginPath(); gctx.moveTo(0,i); gctx.lineTo(360,i); gctx.stroke();
    }
  }
  gridOn.addEventListener('change', ()=>{ drawGrid(); drawSafeSquare75(); });
  drawGrid(); drawSafeSquare75();

  // ----- Underlay image -----
  const bgFile=document.getElementById('bgFile');
  const bgAlpha=document.getElementById('bgAlpha');
  let bgImg=null;

  function renderBG(){
    bctx.clearRect(0,0,bg.width,bg.height);
    if(!bgImg) return;
    bctx.save();
    bctx.globalAlpha = parseFloat(bgAlpha.value);
    const iw=bgImg.naturalWidth, ih=bgImg.naturalHeight;
    const s=Math.min(bg.width/iw, bg.height/ih);
    const dw=iw*s, dh=ih*s;
    const dx=(bg.width-dw)/2, dy=(bg.height-dh)/2;
    bctx.drawImage(bgImg, dx, dy, dw, dh);
    bctx.restore();
  }

  bgFile.addEventListener('change', (e)=>{
    const f=e.target.files && e.target.files[0];
    if(!f) return;
    const img=new Image();
    img.onload=()=>{ bgImg=img; renderBG(); };
    img.src=URL.createObjectURL(f);
  });
  bgAlpha.addEventListener('input', renderBG);

  // ----- Input (pointer) -----
  function getPos(e){
    const r=canvas.getBoundingClientRect();
    return {x:(e.clientX-r.left), y:(e.clientY-r.top)};
  }

  canvas.addEventListener('pointerdown', (e)=>{
    // save state for Undo
    undoStack.push(JSON.parse(JSON.stringify(strokes)));
    drawing=true;
    canvas.setPointerCapture(e.pointerId);
    cur=[];
    strokes.push(cur);
    cur.push(getPos(e));
    redraw(); updateOut();
  });

  canvas.addEventListener('pointermove', (e)=>{
    if(!drawing || !cur) return;
    const p=getPos(e);
    const last=cur[cur.length-1];
    if(last && Math.hypot(p.x-last.x, p.y-last.y) < 0.5) return;
    cur.push(p);
    redraw(); updateOut();
  });

  function endStroke(){
    if(!drawing) return;
    drawing=false;
    cur=null;
    updateOut();
  }
  canvas.addEventListener('pointerup', endStroke);
  canvas.addEventListener('pointercancel', endStroke);
  window.addEventListener('pointerup', endStroke);

  document.getElementById('undoBtn').addEventListener('click', ()=>{
    if(undoStack.length===0) return;
    strokes = undoStack.pop();
    redraw(); updateOut();
  });

  document.getElementById('clearBtn').addEventListener('click', ()=>{
    strokes=[];
    redraw(); updateOut();
  });

  // ----- Geometry / IK -----
  function deg(rad){ return rad*180/Math.PI; }
  function wrapNear(prevDeg, vDeg){
    if(!Number.isFinite(prevDeg)) return vDeg;
    let w=vDeg;
    while(w-prevDeg>180) w-=360;
    while(w-prevDeg<-180) w+=360;
    return w;
  }
  function ikAlphaBeta(x, y, l, prevA, prevB){
    const rho=Math.hypot(x,y);
    const phi=Math.atan2(y,x);
    const rhoC=Math.min(Math.max(rho, 1e-9), 2*l-1e-6);
    const gamma=Math.acos(rhoC/(2*l));
    let A1=deg(phi+gamma), B1=deg(phi-gamma);
    let A2=deg(phi-gamma), B2=deg(phi+gamma);
    A1=wrapNear(prevA, A1); B1=wrapNear(prevB, B1);
    A2=wrapNear(prevA, A2); B2=wrapNear(prevB, B2);
    if(Number.isFinite(prevA)){
      const d1=Math.abs(A1-prevA)+Math.abs(B1-prevB);
      const d2=Math.abs(A2-prevA)+Math.abs(B2-prevB);
      if(d2<d1) return {A:A2, B:B2};
    }
    return {A:A1, B:B1};
  }
  function norm360(v){
    let w=v%360;
    if(w<0) w+=360;
    return w;
  }

  // ----- Build polyline with z -----
  function buildPolylineWithZ(){
    const pts=[];
    const addSegment=(p0,p1,z,steps)=>{
      for(let i=0;i<=steps;i++){
        const t=i/steps;
        pts.push({x:p0.x+(p1.x-p0.x)*t, y:p0.y+(p1.y-p0.y)*t, z:z});
      }
    };
    for(let si=0; si<strokes.length; si++){
      const s=strokes[si];
      if(!s || s.length<1) continue;
      if(travelOn.checked && pts.length){
        const prev=pts[pts.length-1];
        const start=s[0];
        addSegment({x:prev.x,y:prev.y},{x:start.x,y:start.y},0,10);
      }
      for(const p of s){
        pts.push({x:p.x,y:p.y,z:1});
      }
    }
    return pts;
  }

  // ----- Arclength resample keeping z -----
  function resampleArclength(pts, N){
    if(pts.length<2){
      return Array.from({length:N}, ()=>({x:0,y:0,z:0}));
    }
    const segL=[];
    let total=0;
    for(let i=1;i<pts.length;i++){
      const d=Math.hypot(pts[i].x-pts[i-1].x, pts[i].y-pts[i-1].y);
      const dd=Math.max(1e-6, d);
      segL.push(dd);
      total+=dd;
    }
    const outPts=[];
    let si=0, acc=0;
    for(let k=0;k<N;k++){
      const target=(k/(N-1))*total;
      while(si<segL.length-1 && acc+segL[si] < target){
        acc+=segL[si];
        si++;
      }
      const t=(target-acc)/segL[si];
      const p0=pts[si], p1=pts[si+1];
      const x=p0.x+(p1.x-p0.x)*t;
      const y=p0.y+(p1.y-p0.y)*t;
      let z;
      if(p0.z===p1.z) z=p0.z;
      else z=(t<0.5?p0.z:p1.z);
      outPts.push({x,y,z});
    }
    return outPts;
  }

  function updateOut(){
    const N=parseInt(nRows.value,10);
    const l=parseFloat(lArm.value);
    const x0=parseFloat(x0Off.value);
    const y0=parseFloat(y0Off.value);

    const poly=buildPolylineWithZ();
    if(poly.length<2){
      out.value="";
      return;
    }
    const samp=resampleArclength(poly, N);

    let prevA=NaN, prevB=NaN;
    const lines=[];
    for(const p of samp){
      const w = screenToWorld(p.x, p.y, parseFloat($('lArm').value));
      const X = x0 + w.x;
      const Y = y0 + w.y;
      const ab=ikAlphaBeta(X,Y,l,prevA,prevB);
      prevA=ab.A; prevB=ab.B;
      const A=norm360(ab.A), B=norm360(ab.B);
      lines.push(`${A.toFixed(2)},${B.toFixed(2)},${p.z?1:0}`);
    }
    out.value=lines.join("\n");
  }

  for(const el of [travelOn, lArm, x0Off, y0Off, nRows]){
    el.addEventListener('input', updateOut);
    el.addEventListener('change', updateOut);
  }

  updateOut();






  function exportPNG() {
    const draw = document.getElementById("canvas");
    if (!draw) return;
    const link = document.createElement("a");
    link.download = "drawing.png";
    link.href = draw.toDataURL("image/png");
    link.click();
  }


</script>
</body>
</html>
