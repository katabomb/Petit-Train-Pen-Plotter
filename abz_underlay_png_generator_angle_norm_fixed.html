<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>線文(α,β,z) → 下絵PNG生成（角度対応）</title>
<style>
body{margin:0;font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP",sans-serif;background:#fff;color:#111}
header{padding:12px 14px;border-bottom:1px solid #ddd}
.wrap{max-width:1100px;margin:0 auto;padding:12px 14px;display:grid;grid-template-columns:1fr 1fr;gap:12px}
@media(max-width:980px){.wrap{grid-template-columns:1fr}}
.card{background:#f6f6f6;border:1px solid #ddd;border-radius:10px;padding:10px}
.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin:6px 0}
textarea{width:100%;height:240px;border:1px solid #ddd;border-radius:8px;padding:10px;font-family:ui-monospace,monospace;font-size:12px}
button{border:0;border-radius:10px;padding:10px 12px;background:#111;color:#fff;font-weight:600}
canvas{background:#fff;border:1px solid #ddd;border-radius:10px;max-width:100%;height:auto}
label{font-size:12px;color:#666}
.hint{font-size:12px;color:#666}
</style>
</head>
<body>
<header>
<h1>線文(α,β,z) → 下絵PNG生成</h1>
<div class="hint">α,βを<strong>角度(度)</strong>として扱い、表示用に自動正規化します。</div>
</header>

<div class="wrap">
<div class="card">
<div class="row">
<button id="btnSample">サンプル</button>
<button id="btnRender">再描画</button>
<button id="btnPNG">PNG保存</button>
<span id="status" class="hint"></span>
</div>

<label>線文（1行 = α,β,z）</label>
<textarea id="txt"></textarea>

<div class="row">
<label>表示サイズ(mm)</label>
<input type="number" id="sizeMM" value="75" step="1">
<label>（正方形）</label>
</div>

<div class="hint">
このツールは<strong>α,βの数値範囲を自動検出</strong>し、75mm正方形に正規化して表示します。<br>
実機スケールとは切り離した「下絵専用」です。
</div>
</div>

<div class="card">
<canvas id="cv" width="900" height="900"></canvas>
</div>
</div>

<script>
const $ = s=>document.querySelector(s);
const cv = $("#cv");
const ctx = cv.getContext("2d");

function parseLines(text){
  return text.split(/\r?\n/).map(l=>l.trim()).filter(l=>l).map(l=>{
    const p=l.split(/[,\s]+/).map(Number);
    return {a:p[0], b:p[1], z:p[2]??1};
  }).filter(p=>Number.isFinite(p.a)&&Number.isFinite(p.b));
}

function render(){
  const pts=parseLines($("#txt").value);
  if(!pts.length){$("#status").textContent="線文なし";return;}

  // bounds
  const xs=pts.map(p=>p.a), ys=pts.map(p=>p.b);
  const minX=Math.min(...xs), maxX=Math.max(...xs);
  const minY=Math.min(...ys), maxY=Math.max(...ys);

  // uniform scale (no skew)
  const pad = 0.8;
  const sx = (cv.width*pad)/(maxX-minX||1);
  const sy = (cv.height*pad)/(maxY-minY||1);
  const scale = Math.min(sx, sy);

  // center without mirroring or rotation
  const cx = cv.width/2;
  const cy = cv.height/2;
  const ox = cx - ((minX+maxX)/2)*scale;
  const oy = cy - ((minY+maxY)/2)*scale;

  ctx.clearRect(0,0,cv.width,cv.height);

  // 75mm guide (visual only)
  const sizeMM=parseFloat($("#sizeMM").value);
  ctx.strokeStyle="#aaa";
  ctx.strokeRect(cx-scale*sizeMM/2, cy-scale*sizeMM/2, scale*sizeMM, scale*sizeMM);

  // draw path
  ctx.strokeStyle="#000";
  ctx.lineWidth=2;
  ctx.lineCap="round";
  ctx.lineJoin="round";
  ctx.beginPath();
  let prev=null;
  for(const p of pts){
    const x = ox + p.a*scale;
    const y = oy + p.b*scale; // same orientation as source (no flip)
    if(!prev){ ctx.moveTo(x,y); }
    else{
      if(prev.z===1 && p.z===1) ctx.lineTo(x,y);
      else{ ctx.stroke(); ctx.beginPath(); ctx.moveTo(x,y); }
    }
    prev=p;
  }
  ctx.stroke();
  $("#status").textContent=`点数 ${pts.length}`;
}

function exportPNG(){
  const url=cv.toDataURL("image/png");
  const w=window.open("");
  w.document.write('<img src="'+url+'" style="max-width:100%">');
}

const SAMPLE="135,40,1\n140,45,1\n145,40,1";
$("#btnSample").onclick=()=>{$("#txt").value=SAMPLE;render();};
$("#btnRender").onclick=render;
$("#btnPNG").onclick=exportPNG;

$("#txt").value=SAMPLE;
render();
</script>
</body>
</html>
