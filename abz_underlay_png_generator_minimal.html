<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>線文(α,β,z) → 下絵PNG生成（最小正規化・回転なし）</title>
<style>
body{margin:0;font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP",sans-serif;background:#fff;color:#111}
header{padding:12px 14px;border-bottom:1px solid #ddd}
.wrap{max-width:1100px;margin:0 auto;padding:12px 14px;display:grid;grid-template-columns:1fr 1fr;gap:12px}
@media(max-width:980px){.wrap{grid-template-columns:1fr}}
.card{background:#f6f6f6;border:1px solid #ddd;border-radius:10px;padding:10px}
.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin:6px 0}
textarea{width:100%;height:240px;border:1px solid #ddd;border-radius:8px;padding:10px;font-family:ui-monospace,monospace;font-size:12px}
button{border:0;border-radius:10px;padding:10px 12px;background:#111;color:#fff;font-weight:600}
canvas{background:#fff;border:1px solid #ddd;border-radius:10px;max-width:100%;height:auto}
label{font-size:12px;color:#666}
.hint{font-size:12px;color:#666}
</style>
</head>
<body>
<header>
<h1>線文(α,β,z) → 下絵PNG生成</h1>
<div class="hint">
回転・反転・スキューを一切行いません。<br>
x=α, y=β をそのまま<strong>平行移動＋等倍スケール</strong>で75mm正方形に収めます。
</div>
</header>

<div class="wrap">
<div class="card">
<div class="row">
<button id="btnSample">サンプル</button>
<button id="btnRender">再描画</button>
<button id="btnPNG">PNG保存</button>
<span id="status" class="hint"></span>
</div>

<label>線文（1行 = α,β,z）</label>
<textarea id="txt"></textarea>

<div class="row">
<label>表示サイズ(mm)</label>
<input type="number" id="sizeMM" value="75" step="1">
<label>（正方形）</label>
</div>

<div class="hint">
※ α,β は<strong>角度のまま</strong>扱います。形状の相似性のみを保証します。
</div>
</div>

<div class="card">
<canvas id="cv" width="900" height="900"></canvas>
</div>
</div>

<script>
const $ = s=>document.querySelector(s);
const cv = $("#cv");
const ctx = cv.getContext("2d");

function parseLines(text){
  return text.split(/\r?\n/)
    .map(l=>l.trim()).filter(Boolean)
    .map(l=>{
      const p=l.split(/[,\s]+/).map(Number);
      return {x:p[0], y:p[1], z:p[2]??1};
    })
    .filter(p=>Number.isFinite(p.x)&&Number.isFinite(p.y));
}

function render(){
  const pts=parseLines($("#txt").value);
  if(!pts.length){$("#status").textContent="線文なし";return;}

  // bounding box
  const xs=pts.map(p=>p.x), ys=pts.map(p=>p.y);
  const minX=Math.min(...xs), maxX=Math.max(...xs);
  const minY=Math.min(...ys), maxY=Math.max(...ys);

  const sizeMM=parseFloat($("#sizeMM").value);

  // uniform scale ONLY (no rotation, no flip)
  const scale=Math.min(
    (cv.width*0.8)/(maxX-minX||1),
    (cv.height*0.8)/(maxY-minY||1)
  );

  const cx=cv.width/2;
  const cy=cv.height/2;

  // center by translation only
  const ox=cx - ((minX+maxX)/2)*scale;
  const oy=cy - ((minY+maxY)/2)*scale;

  ctx.clearRect(0,0,cv.width,cv.height);

  // guide
  ctx.strokeStyle="#aaa";
  ctx.strokeRect(
    cx-scale*sizeMM/2,
    cy-scale*sizeMM/2,
    scale*sizeMM,
    scale*sizeMM
  );

  // draw
  ctx.strokeStyle="#000";
  ctx.lineWidth=2;
  ctx.lineCap="round";
  ctx.lineJoin="round";
  ctx.beginPath();
  let prev=null;
  for(const p of pts){
    const x=ox + p.x*scale;
    const y=oy + p.y*scale;
    if(!prev){
      ctx.moveTo(x,y);
    }else{
      if(prev.z===1 && p.z===1) ctx.lineTo(x,y);
      else{ctx.stroke();ctx.beginPath();ctx.moveTo(x,y);}
    }
    prev=p;
  }
  ctx.stroke();

  $("#status").textContent=`点数 ${pts.length}`;
}

function exportPNG(){
  const url=cv.toDataURL("image/png");
  const w=window.open("");
  if(!w){alert("ポップアップがブロックされました");return;}
  w.document.write('<img src="'+url+'" style="max-width:100%">');
}

const SAMPLE="135,40,1\n140,45,1\n145,40,1";
$("#btnSample").onclick=()=>{$("#txt").value=SAMPLE;render();};
$("#btnRender").onclick=render;
$("#btnPNG").onclick=exportPNG;

$("#txt").value=SAMPLE;
render();
</script>
</body>
</html>
